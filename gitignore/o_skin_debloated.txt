import * as THREE from "three";
import { ZipLoadingManager } from "./ziploader.js";
import { VertexNormalsHelper } from "three/addons/helpers/VertexNormalsHelper.js";
const DEBUG = new URLSearchParams(location.search).has("debug");
function extrudeTexture(image) {
  const padding = 0;
  const imageWidth = image.width;
  const imageHeight = image.height;
  const canvas = new OffscreenCanvas(image.width + padding * 2, image.height + padding * 2);
  const ctx = canvas.getContext("2d");
  ctx.drawImage(image, padding, padding, imageWidth, imageHeight);
  ctx.drawImage(image, padding, padding, imageWidth, imageHeight);
  ctx.drawImage(image, 0, 0, 1, imageHeight, 0, padding, padding, imageHeight);
  ctx.drawImage(image, imageWidth - 1, 0, 1, imageHeight, imageWidth + padding, padding, padding, imageHeight);
  ctx.drawImage(image, 0, 0, imageWidth, 1, padding, 0, imageWidth, padding);
  ctx.drawImage(image, 0, imageHeight - 1, imageWidth, 1, padding, imageHeight + padding, imageWidth, padding);
  ctx.drawImage(image, 0, 0, 1, 1, 0, 0, padding, padding);
  ctx.drawImage(image, imageWidth - 1, 0, 1, 1, imageWidth + padding, 0, padding, padding);
  ctx.drawImage(image, 0, imageHeight - 1, 1, 1, 0, imageHeight + padding, padding, padding);
  ctx.drawImage(
    image,
    imageWidth - 1,
    imageHeight - 1,
    1,
    1,
    imageWidth + padding,
    imageHeight + padding,
    padding,
    padding
  );
  (async () => {
    const blob = await canvas.convertToBlob();
    const img = document.createElement("img");
    img.src = URL.createObjectURL(blob);
    img.style.imageRendering = "crisp-edges";
    document.body.appendChild(img);
  })();
  return canvas.transferToImageBitmap();
}
function SkinMaterial(texture) {
  const vertShader = `
        attribute float highlight;
        uniform bool SHADE;
        uniform int LIGHTSIDE;
        varying vec2 vUv;
        varying float light;
        varying float lift;
        float AMBIENT = 0.5;
        float XFAC = -0.15;
        float ZFAC = 0.05;
        void main()
        {
            if (SHADE) {
                vec3 N = normalize( vec3( modelMatrix * vec4(normal, 0.0) ) );
                if (LIGHTSIDE == 1) {
                    float temp = N.y;
                    N.y = N.z * -1.0;
                    N.z = temp;
                }
                if (LIGHTSIDE == 2) {
                    float temp = N.y;
                    N.y = N.x;
                    N.x = temp;
                }
                if (LIGHTSIDE == 3) {
                    N.y = N.y * -1.0;
                }
                if (LIGHTSIDE == 4) {
                    float temp = N.y;
                    N.y = N.z;
                    N.z = temp;
                }
                if (LIGHTSIDE == 5) {
                    float temp = N.y;
                    N.y = N.x * -1.0;
                    N.x = temp;
                }
                float yLight = (1.0+N.y) * 0.5;
                light = yLight * (1.0-AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
            } else {
                light = 1.0;
            }
            if (highlight == 2.0) {
                lift = 0.22;
            } else if (highlight == 1.0) {
                lift = 0.1;
            } else {
                lift = 0.0;
            }
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
        }`;
  const fragShader = `
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D map;
        uniform bool SHADE;
        uniform bool EMISSIVE;
        uniform vec3 LIGHTCOLOR;
        varying vec2 vUv;
        varying float light;
        varying float lift;
        void main(void)
        {
            vec2 pixelSize = 1.0 / vec2(textureSize(map, 0));
            vec2 adjustedUv = vUv + 0.5 * pixelSize; 
            vec2 clampedUv = clamp(vUv, 0.0, 1.0); 
            vec4 color = texture2D(map, clampedUv);
            if (color.a < 0.01) discard;
            if (EMISSIVE == false) {
                gl_FragColor = vec4(lift + color.rgb * light, color.a);
                gl_FragColor.r = gl_FragColor.r * LIGHTCOLOR.r;
                gl_FragColor.g = gl_FragColor.g * LIGHTCOLOR.g;
                gl_FragColor.b = gl_FragColor.b * LIGHTCOLOR.b;
            } else {
                float light_r = (light * LIGHTCOLOR.r) + (1.0 - light * LIGHTCOLOR.r) * (1.0 - color.a);
                float light_g = (light * LIGHTCOLOR.g) + (1.0 - light * LIGHTCOLOR.g) * (1.0 - color.a);
                float light_b = (light * LIGHTCOLOR.b) + (1.0 - light * LIGHTCOLOR.b) * (1.0 - color.a);
                gl_FragColor = vec4(lift + color.r * light_r, lift + color.g * light_g, lift + color.b * light_b, 1.0);
            }
            if (lift > 0.2) {
                gl_FragColor.r = gl_FragColor.r * 0.6;
                gl_FragColor.g = gl_FragColor.g * 0.7;
            }
        }`;
  const global_light_color = new THREE.Color().setHex(0xffffff);
  const global_light_side = 4;
  const brightness = 50;
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      map: { type: "t", value: texture },
      SHADE: { type: "bool", value: true },
      LIGHTCOLOR: { type: "vec3", value: new THREE.Color().copy(global_light_color).multiplyScalar(brightness / 50) },
      LIGHTSIDE: { type: "int", value: global_light_side },
      EMISSIVE: { type: "bool", value: false },
    },
    vertexShader: vertShader,
    fragmentShader: fragShader,
    blending: THREE.NormalBlending,
    side: THREE.DoubleSide,
    transparent: true,
  });
  mat.name = "SkinMaterial";
  return mat;
}
function SkinTexture(texture) {
  texture.magFilter = THREE.NearestFilter;
  texture.minFilter = THREE.NearestFilter;
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.generateMipmaps = false;
  texture.needsUpdate = true;
  return texture;
}
function createLimbMesh(cube, texture, mirroredLimbs, boneName, pivot) {
  const geometry = buildCubeGeometry(cube);
  setUVs(geometry, cube.uv, cube.size, 64, 64);
  if (mirroredLimbs && ["leftArm", "leftLeg"].includes(boneName)) {
    const posAttr = geometry.attributes.position;
    const pivotX = pivot ? pivot[0] : 0;
    for (let i = 0; i < posAttr.count; i++) {
      const x = posAttr.getX(i);
      posAttr.setX(i, 2 * pivotX - x);
    }
    posAttr.needsUpdate = true;
    const uvAttr = geometry.attributes.uv;
    for (let i = 0; i < uvAttr.count; i++) {
      uvAttr.setX(i, 1.0 - uvAttr.getX(i));
    }
    uvAttr.needsUpdate = true;
    const normalAttr = geometry.attributes.normal;
    if (normalAttr) {
      for (let i = 0; i < normalAttr.count; i++) {
        normalAttr.setX(i, -normalAttr.getX(i));
      }
      normalAttr.needsUpdate = true;
    }
  }
  return new THREE.Mesh(geometry, SkinMaterial(SkinTexture(texture)));
}
function defaultGeometry(slim) {
  const width = slim ? 3 : 4;
  return {};
}
function setUVs(box, uv, xyz, w, h, mirror = false) {
  const pixelOffsetU = 0;
  const pixelOffsetV = 0;
  const toFaceVertices = (x1, y1, x2, y2, flip = false) => {
    let verts = [
      new THREE.Vector2((x1 + pixelOffsetU) / w, 1.0 - (y2 + pixelOffsetV) / h),
      new THREE.Vector2((x2 - pixelOffsetU) / w, 1.0 - (y2 + pixelOffsetV) / h),
      new THREE.Vector2((x2 - pixelOffsetU) / w, 1.0 - (y1 - pixelOffsetV) / h),
      new THREE.Vector2((x1 + pixelOffsetU) / w, 1.0 - (y1 - pixelOffsetV) / h),
    ];
    if (flip) {
      verts = [verts[1], verts[0], verts[3], verts[2]];
    }
    return verts;
  };
  let top, bottom, left, front, right, back;
  if (uv instanceof Array) {
    let [u, v] = uv;
    const [width, height, depth] = xyz;
    const flipLR = mirror;
    top = toFaceVertices(u + depth, v, u + width + depth, v + depth);
    bottom = toFaceVertices(u + width + depth, v, u + width * 2 + depth, v + depth);
    left = toFaceVertices(u, v + depth, u + depth, v + depth + height, flipLR);
    front = toFaceVertices(u + depth, v + depth, u + width + depth, v + depth + height);
    right = toFaceVertices(u + width + depth, v + depth, u + width + depth * 2, v + height + depth, flipLR);
    back = toFaceVertices(u + width + depth * 2, v + depth, u + width * 2 + depth * 2, v + height + depth);
  } else {
    function face(a, flip = false) {
      if (!a) return toFaceVertices(0, 0, 1, 1);
      const [u, v] = a.uv;
      const [u2, v2] = a.uv_size;
      return toFaceVertices(u, v, u + u2, v + v2, flip);
    }
    top = face(uv.up);
    bottom = face(uv.down);
    left = face(uv.east, mirror);
    front = face(uv.north);
    right = face(uv.west, mirror);
    back = face(uv.south);
  }
  const uvAttr = box.attributes.uv;
  uvAttr.array = new Float32Array(
    [
      right[3],
      right[2],
      right[0],
      right[1],
      left[3],
      left[2],
      left[0],
      left[1],
      top[3],
      top[2],
      top[0],
      top[1],
      bottom[0],
      bottom[1],
      bottom[3],
      bottom[2],
      front[3],
      front[2],
      front[0],
      front[1],
      back[3],
      back[2],
      back[0],
      back[1],
    ].flatMap((e) => [e.x, e.y])
  );
  uvAttr.needsUpdate = true;
}
function parsePolyMesh(polyMesh) {
  const expandedPositionsArray = [];
  const expandedNormalsArray = [];
  const expandedUvsArray = [];
  const indicesArray = [];
  const { positions, normals, uvs, polys, normalized_uvs } = polyMesh;
  const flipNormal = (n) => {
    return [-n[0], -n[1], -n[2]];
  };
  polys.forEach((polygon) => {
    const polygonIndices = polygon.map((vertex) => {
      const [positionIndex, normalIndex, uvIndex] = vertex;
      expandedPositionsArray.push(...positions[positionIndex]);
      expandedNormalsArray.push(...flipNormal(normals[normalIndex]));
      const uv = uvs[uvIndex];
      expandedUvsArray.push(...(normalized_uvs ? uv : uv.map((val, i) => val * (i % 2 === 0 ? 1 : 1))));
      return expandedPositionsArray.length / 3 - 1;
    });
    if (polygon.length === 3) {
      indicesArray.push(...polygonIndices);
    } else if (polygon.length === 4) {
      indicesArray.push(polygonIndices[0], polygonIndices[1], polygonIndices[2]);
      indicesArray.push(polygonIndices[2], polygonIndices[3], polygonIndices[0]);
    }
  });
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute("position", new THREE.Float32BufferAttribute(expandedPositionsArray, 3));
  geometry.setAttribute("normal", new THREE.Float32BufferAttribute(expandedNormalsArray, 3));
  geometry.setAttribute("uv", new THREE.Float32BufferAttribute(expandedUvsArray, 2));
  geometry.setIndex(indicesArray);
  geometry.setAttribute("color", new THREE.Float32BufferAttribute(expandedUvsArray, 2));
  return geometry;
}
function loadBones(bones, texturewidth, textureheight, material, texture) {
  const boneMap = {};
  const boneDataMap = {};
  const rootBones = [];
  for (const bone of bones) {
    const pivot = new THREE.Object3D();
    pivot.name = bone.name;
    if (bone.rotation) {
      pivot.rotation.setFromVector3(new THREE.Vector3(...bone.rotation));
    }
    if (bone.cubes) {
      bone.cubes.forEach((cube) => {
        let mesh;
        try {
          mesh = createLimbMesh(cube, texture, true, bone.name);
          if (!mesh || !(mesh instanceof THREE.Mesh)) {
            throw new Error("Invalid mesh");
          }
          const origin = cube.origin.map((o, i) => o + cube.size[i] / 2);
          origin[2] = -origin[2];
          mesh.position.fromArray(origin);
          mesh.position.sub(new THREE.Vector3(...bone.pivot));
          mesh.isMinecraftMesh = true;
        } catch (e) {
          const size = cube.size.map((s) => s + (cube.inflate ?? 0));
          const origin = cube.origin.map((o, i) => o + cube.size[i] / 2);
          origin[2] = -origin[2];
          const box = new THREE.BoxGeometry(...size);
          if (cube.mirror === true) {
            box.scale(-1, 1, 1);
          }
          setUVs(box, cube.uv, cube.size, texturewidth, textureheight, cube.mirror === true);
          mesh = new THREE.Mesh(box, material);
          mesh.position.fromArray(origin);
          mesh.position.sub(new THREE.Vector3(...bone.pivot));
          mesh.isMinecraftMesh = true;
        }
        pivot.add(mesh);
      });
    }
    boneMap[bone.name] = pivot;
    boneDataMap[bone.name] = bone;
  }
  for (const name in boneMap) {
    const bone = boneMap[name];
    const data = boneDataMap[name];
    if (data.parent && boneMap[data.parent]) {
      const parent = boneMap[data.parent];
      const parentPivot = boneDataMap[data.parent].pivot;
      const relPivot = [data.pivot[0] - parentPivot[0], data.pivot[1] - parentPivot[1], data.pivot[2] - parentPivot[2]];
      bone.position.set(...relPivot);
      parent.add(bone);
    } else {
      bone.position.set(...data.pivot);
      rootBones.push(bone);
    }
  }
  return rootBones;
}
function applyStaticAnimation(model, animationDef) {
  const bones = animationDef.bones;
  if (!bones) return;
  model.traverse((child) => {
    if (!child.isObject3D || !bones[child.name]) return;
    const boneAnim = bones[child.name];
    if (boneAnim.rotation) {
      const rot = boneAnim.rotation.map((deg) => THREE.MathUtils.degToRad(deg));
      child.rotation.set(...rot);
    }
  });
}
function applyAnimationRecursively(object3d, animBones, parentHasAnim = false) {
  const anim = animBones[object3d.name.toLowerCase()];
  const hasAnim = anim?.rotation !== undefined;
  if (hasAnim) {
    object3d.rotation.set(
      THREE.MathUtils.degToRad(anim.rotation[0]),
      THREE.MathUtils.degToRad(anim.rotation[1]),
      THREE.MathUtils.degToRad(anim.rotation[2])
    );
  } else if (parentHasAnim) {
  }
  object3d.children.forEach((child) => applyAnimationRecursively(child, animBones, hasAnim || parentHasAnim));
}
export function generateSkinModel(texture, geometry, scale = 1, skin, animationDefs) {
  const material = SkinMaterial(texture);
  const bones = loadBones(geometry.bones, texture.image.width, texture.image.height, material, texture);
  const bonesMap = {};
  bones.forEach((b) => (bonesMap[b.name.toLowerCase()] = b));
  geometry.bones.forEach((bone) => {
    if (bone.parent) {
      const parent = bonesMap[bone.parent.toLowerCase()];
      const child = bonesMap[bone.name.toLowerCase()];
      if (parent && child) parent.add(child);
    }
  });
  const root = new THREE.Object3D();
  bones.forEach((b) => {
    if (!geometry.bones.find((bn) => bn.name.toLowerCase() === b.name.toLowerCase())?.parent) {
      root.add(b);
    }
  });
  if (skin.animations) {
    for (const key in skin.animations) {
      const animName = skin.animations[key];
      const anim = animationDefs[animName];
      if (anim && anim.bones) {
        for (const boneName in anim.bones) {
          const bone = bonesMap[boneName.toLowerCase()];
          const transform = anim.bones[boneName];
          if (bone) {
            if (transform.rotation) {
              bone.rotation.set(
                THREE.MathUtils.degToRad(transform.rotation[0]),
                THREE.MathUtils.degToRad(transform.rotation[1]),
                THREE.MathUtils.degToRad(transform.rotation[2])
              );
            }
            if (transform.position) {
              bone.position.set(...transform.position);
            }
          }
        }
      }
    }
  }
  return root;
}
async function loadTexture(loadingManager, url) {
  const loader = new THREE.TextureLoader(loadingManager);
  return loader.loadAsync(url);
}
export class SkinpackLoader extends THREE.Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    if (url instanceof Blob) {
      scope.parse(url).then(onLoad);
      return;
    }
    const loader = new THREE.FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("blob");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      function (blob) {
        try {
          scope.parse(blob).then(onLoad);
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      },
      onProgress,
      onError
    );
  }
  async parse(blob) {
    const zr = new zip.ZipReader(new zip.BlobReader(blob));
    const loadingManager = new ZipLoadingManager(zr);
    await loadingManager.Load();

    const loader = new THREE.FileLoader(loadingManager);
    if (!loadingManager.entries.has("manifest.json")) {
      loadingManager.entries.forEach((v, k) => {
        if (k.endsWith("manifest.json")) {
          loadingManager.baseFolder = k.split("/").slice(0, -1);
        }
      });
    }
    const manifest = JSON.parse(await loader.loadAsync("manifest.json"));
    if (manifest.modules[0].type == "persona_piece") {
      return await this.parse_persona(loadingManager, loader);
    } else {
      return this.parse_skin(loadingManager, loader);
    }
  }
  async parse_skin(loadingManager, loader) {
    const skins_list = JSON.parse(await loader.loadAsync("skins.json"));
    let geometry_list = {};
    try {
      geometry_list = JSON.parse(await loader.loadAsync("geometry.json"));
    } catch (e) {}
    const animationDefs = {
      "animation.player.move.arms.zombie": {
        loop: true,
        bones: {
          leftArm: { rotation: [-90, 0, 0] },
          rightArm: { rotation: [-90, 0, 0] },
        },
      },
      "animation.player.move.arms.statue_of_liberty": {
        loop: true,
        bones: {
          rightarm: { rotation: [180, 0, -17.2] },
        },
      },
    };
    const out = [];
    for (const i in skins_list.skins) {
      const skin = skins_list.skins[i];
      let geometry;
      switch (skin.geometry) {
        case "geometry.humanoid.customSlim":
        case "geometry.humanoid":
          geometry = defaultGeometry(true);
          break;
        case "geometry.humanoid.custom":
          geometry = defaultGeometry(false);
          break;
        default:
          geometry = geometry_list[skin.geometry];
          break;
      }
      try {
        const texture = await loadTexture(loadingManager, skin.texture)
          .then((t) => SkinTexture(t))
          .catch((e) => {
            console.error("failed to load texture", skin);
          });
        const mesh = generateSkinModel(texture, geometry, 2, skin, animationDefs);
        mesh.name = skin.localization_name;
        out.push(mesh);
      } catch (e) {
        console.error("failed to load", skin, e);
      }
    }
    return out;
  }
}
